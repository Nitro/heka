-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

--[[
Converts stat values extracted from statmetric messages to circular buffer
data and periodically emits messages containing this data to be graphed by a
DashboardOutput.

Config:

- title (string, optional, default "Stats"):
    Title for the graph output generated by this filter.

- num_rows (uint, optional, default 300):
    The number of rows to store in our circular buffer. Each row represents
    one time interval.

- secs_per_row (uint, optional, default 1):
    The number of seconds in each circular buffer time interval.

- stats (string):
    Space separated list of stat names. Each specified stat will be expected
    to be found in the fields of the received statmetric messages, and will be
    extracted and inserted into its own column in the accumulated circular
    buffer.

- stat_labels (string):
    Space separated list of header label names to use for the extracted stats.
    Must be in the same order as the specified stats. Any label longer than 15
    characters will be truncated.

*Example Heka Configuration*

.. code-block:: ini

    [stat-graph]
    type = "SandboxFilter"
    filename = "lua_filters/stat_graph.lua"
    ticker_interval = 10
    preserve_data = true
    message_matcher = "Type == 'heka.statmetric'"

      [stat-graph.config]
      num_rows = 1440
      secs_per_row = 10
      stats = "stats.counters.hits.count stats.counters.misses.count"
      stat_labels = "hits misses"
--]]
require("circular_buffer")
require("string")

local idx_num
local stat_value
--local debug

local num_rows = read_config("num_rows") or 300
local secs_per_row = read_config("secs_per_row") or 1
local stats = {}
local i = 1
for stat in string.gmatch(read_config("stats"), "%S+") do
    stats[i] = stat
    i = i + 1
end
local stat_labels = {}
i = 1
for stat_label in string.gmatch(read_config("stat_labels"), "%S+") do
    stat_labels[i] = stat_label
    i = i + 1
end
local num_cols = #stats

-- # rows, # cols, # seconds per row
cbuf = circular_buffer.new(num_rows, num_cols, secs_per_row)
cbuf_idxs = {}
field_names = {}
for i, stat_name in pairs(stats) do
    cbuf_idxs[i] = cbuf:set_header(i, stat_labels[i])
    field_names[i] = string.format("Fields[%s]", stat_name)
end

function process_message()
    local ts = read_message("Fields[timestamp]") * 1e9
    for i, stat_name in pairs(stats) do
        stat_value = read_message(field_names[i])
        if stat_value then
            cbuf:add(ts, cbuf_idxs[i], stat_value)
        end
    end
    return 0
end

function timer_event(ns)
    inject_payload("cbuf", "Stats", cbuf)
end
